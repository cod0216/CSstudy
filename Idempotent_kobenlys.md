# 🥑 멱등성 - Idempotent
> *어떤 연산이나 요청을 여러 번 반복수행해도 최초 수행 결과 이외의 변화가 발생하지 않는 성질*

프로그래밍에서 **멱등성**이란 개념이 자주 사용되기도 한다. 실제로 **멱등성**에 대해 잘 알지 못해도 알게 모르게 자주 사용해보았고, 멱등성을 이용한 개발을 해보았을 것이다.

이를 쉽게 풀어서 정리해보려고 한다.


# 코드로 보는 멱등성

```java

// 멱등 함수: 항상 같은 입력 -> 같은 출력 (상태 변화 없음)
public class Idempotent {
    public int giveNumber(int number) {
        return number + 2025;
    }
}

// 비멱등 함수: 같은 입력이라도 호출할 때마다 결과가 바뀜
public class NonIdempotent {
    private int counter = 0;

    public int giveNumber(int number) {
        counter++; // 상태 변화 발생
        return number + counter;
    }
}
```

**Idempotent 클래스의 giveNumber함수는 멱등하게 설계되었습니다. **
동일한 요청에 대해 2025를 더해서 **항상 같은** 값을 리턴하고 
이를 printNumber 함수는 멱등하다고 표현합니다.

**반대로 NonIdempotent의 giveNumber는 비멱등하게 설계되었습니다.**
요청마다 내부 counter 값이 증가하게 되고 
이는 동일한 요청에 대해 **항상 다른**값을 리턴하고 
이를 printNumber 함수는 비멱등하다고 표현합니다.


# 📑 HTTP Method와 멱등성
#### RFC 7231 (HTTP/1.1 Semantics and Content)
| HTTP Method | 멱등성 여부 | 설명 |
|-------------|-------------|------|
| **GET**     | ✅ 멱등함   | 리소스를 조회만 하며 서버 상태를 변경하지 않음. 동일 요청 반복해도 결과 동일. |
| **HEAD**    | ✅ 멱등함   | GET과 유사하되, 응답 본문 없이 헤더만 반환. 서버 상태 변경 없음. |
| **PUT**     | ✅ 멱등함   | 리소스를 "지정된 값으로 덮어쓰기" 때문에 여러 번 호출해도 결과는 동일. |
| **DELETE**  | ✅ 멱등함   | 리소스를 삭제. 이미 삭제된 리소스를 다시 삭제해도 상태 변화 없음. |
| **POST**    | ❌ 비멱등함 | 서버에 데이터를 생성하거나 처리하는 요청. 반복 시 중복 처리 가능성 존재. |
| **PATCH**   | ❌ 비멱등함 | 리소스 일부를 수정. 수정 대상이 누적될 수 있어 멱등하지 않음. |

RFC 7231 명세에 따르면 **GET, PUT, HEAD, DELETE**는 멱등하게 설계를 해야한다고 명시되어있습니다.

HTTP Method를 이용한 API 설계에서는 **GET,HEAD**는 **안정성과 멱등성**을요구하고 **PUT, DELETE**는 **멱등성**만 요구합니다.

### 🧐 서버 리소스가 변경되는데 왜 PUT, DELETE가 멱등성을 가지나요?
먼저 멱등성의 핵심은 **같은 요청을 여러 번 보내도 결과는 같음**이다. 
물론 서버 리소스가 변경이 되지 않는 것도 부분적으로 맞지만 완전한 정의는 아닙니다. 

> 
- DELETE Method를 통해 user 1 삭제하는 API를 다건 요청한 경우 
1. 첫 번째 요청 -> user 1 삭제 완료 (서버에서 user 1 존재 x) 
2. 두 번째 요청 -> user 1 찾지 못해 실패 (서버에서 user 1 존재 x) 
3. 세 번째 요청 -> user 1 찾지 못해 실패 (서버에서 user 1 존재 x) 
4. ... 

이 과정에서 서버의 리소스가 제거된 후 서버의 상태나 응답은 더 이상 변경되지 않으므로 결과적으로 멱등합니다. 

이러한 이유 때문에 **DELETE, PUT**은 같은 요청에 대해 항상 같은 결과를 제공하므로 멱등성을 가진다라고 이야기할 수 있게 됩니다.

### 🧐 PATCH, PUT 둘다 리소스 수정에 쓰이는데 왜 멱등성 여부가 다른가요?

- PUT : 전체 업데이트
- PATCH : 부분 업데이트

PUT은 리소스를 전체 업데이트합니다. 즉 요청에 들어있는 데이터가 최종 상태임을 의미하고 개발됩니다. 즉 같은 PUT 요청을 여러 번 보내면 결과는 항상 같게  되어 멱등성을 보장합니다.

반대로 PATCH는 리소스의 일부분을 업데이트합니다
```json
PATCH /account/1
{
  "balance": "+100"
}
```
같은 PATCH 요청을 여러 번 보내게 된다면 balance는 100 * N 만큼 늘어나게 되어
서버 리소스의 결과가 항상 달라지게 되어 멱등성을 보장하지 못하게 됩니다.

물론 PATCH 요청은 개발의도에 따라 멱등 or 비멱등한 요청으로 변경될 수 있습니다.
다음과 같이 상태 설정형 요청이라면 멱등성을 가질 수 있습니다.

```json
PATCH /account/1
{
  "isActive": "Y"
}
```

이렇게 의도가 되었다면 여러 번 요청해도 결과는 같기 때문에 멱등하게됩니다.


# ✅ POST, PATCH 에서 멱등성이 필요하다면?

### 멱등키 - Idempotent key
> 같은 요청이 여러번 서버에 전송되더라도 단 한번만 처리되도록 보장하기 위한 고유한 값

예를 들어, 네트워크 오류로 인한 retry, 더블 클릭 등 이슈로 인한 상품 결제 요청이 여러번 서버에 전송되는 상황을 상상해보자.

>
- POST Method를 이용한 상품결제 API 중복 전송
1. 첫 번째 요청 -> 상품 결제 완료(서버 리소스 증가)
2. 두 번째 요청 -> 상품 결제 완료(서버 리소스 증가)
3. 세 번째 요청 -> 상품 결제 완료(서버 리소스 증가)
4. ...

이처럼 **POST는 멱등하지 않은 메서드**이기 때문에, 동일 요청이 여러 번 전달되면 **서버의 상태가 매번 달라지고**, 결과 또한 달라지게 된다.  
결과적으로 **상품이 여러 번 결제되는 상황**이 발생할 수 있으며, 사용자 입장에서는 **금전적인 손해**로 이어질 수 있다.

즉 POST요청이지만 **멱등성**이 필요한 상황이다.

이처럼 POST나 PATCH 처럼 비멱등한 HTTP Method에 멱등성을 부여하기 위해 **멱등키(Idempotent-Key)**를 사용한다.


# 📚 결론
- 멱등성을 고려한 API설계는 Retry, 더블클릭요청, 네트워크 오류 등 다양한 예외사항에 서버가 안정적으로 대응가능 하게 한다.
- 멱등성에서 **결과의 같음**은 응답뿐만 아니라, 서버 리소스의 최종상태 또한 같음을 의미한다.
- RFC 7231 명세에 의거하여 개발을 하되 서비스에 맞는 유연한 개발도 필요하다.

