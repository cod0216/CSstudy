# 🤖 데이터 정합성이란?
> 데이터 정합성이란, 시스템이 다루는 데이터가 항상 일관성 있고 신뢰할 수 있는 상태를 유지하는 것을 말합니다.

즉, 데이터의 값과 구조가 서로 일치하거나, 논리적으로 이상함이 없어야 합니다. 대표적인 두 가지 정합성 모델을 알아보겠습니다.

# ACID
전통적인 관계형 DB나 단일 트랜잭션 환경에서 중요하게 여기는 강력한 트랜잭션관리 모델입니다.
각각 _원자성, 일관성, 고립성, 영속성_ 을 뜻한다.

- **Atomicity** : 전부다 성공하거나, 실패하거나.
- **Consistency** : 트랜잭션완료 후에도 데이터 무결성 보장
- **Isolation** : 동시에 수행되는 트랜잭션은 서로 간섭할수 없음.
- **Durability** : 트랜잭션이 완료되어 커밋된 데이터는 영구적 저장


# BASE
NoSQL, MSA, 분산 시스템 환경에서 자주 언급되고 사용되는 최종적 일관성을 보장하는 모델입니다.

- **Basically Available** : 시스템이 항상 정확성보단 응답을 우선으로 제공

- **Soft state** : 일시적 정합성 훼손

- **Eventual consistency** : 최종적으로 일관성을 보장함.


# 🧐 MSA를 공부하면서
MSA기반 서비스를 설계하면서 어려웠던 부분은 어떤 단위로 서비스를 분리하는 것이었다.

명확한 기준 없이 크거나, 작게 나누게 된다면 성능뿐만 아니라
MSA 아키텍처를 선택한 이유까지 손해를 볼 것 같았다.

정합성을 공부하면서 나름대로 서비스를 분리하는 기준을 가지게 되었는데 바로 보장되어야하는 데이터 정합성 모델에 따라 분리하면 되는 것이였다.

크게 두 가지 경우가 있다.

## 💡트랜잭션의 과정까지 정합성이 지켜져야 하는 경우

![](https://velog.velcdn.com/images/dl_01312/post/df597635-8faf-4cce-9162-adf1a66a4dba/image.png)

계좌송금을 그림으로 표현해봤습니다.

내부적으로 송금을 처리할 때, 정석대로라면 반드시 **계좌 A**에서 **5,000원**을 출금하고, 이어서 **계좌 B**에 **5,000원**이 입금 처리되어야 합니다.

그 이유는 만약 **계좌 A**에서 출금하지 않고 **계좌 B**로 송금한다면, 그 사이에 다른 **계좌 C**로의 **3,000원** 송금 트랜잭션이 끼어들어 **계좌 A**의 잔고가 **-3,000**원이 되어버리는 문제가 발생할 수 있기 때문입니다.

즉 이러한 시나리오는 **작업의 순서가 명확하게 보장**되어야 하며, 이는 곧 **트랜잭션의 과정까지 정합성이 유지**되어야 한다는 것을 의미합니다.


## 💡트랜잭션의 결과만 정합성이 필요한 경우


![](https://velog.velcdn.com/images/dl_01312/post/09dc39cc-081a-4821-86b6-0dc0a61b8a73/image.png)

상품을 결제하고 이벤트 쿠폰을 받는 시나리오입니다.
언뜻 보기에 상품 결제가 성공한 후 쿠폰 증정까지 하나의 트랜잭션으로 엄격하게 보장해야 할 것처럼 느껴집니다.

그러나 실제로 쿠폰 증정이 0.5초나 1초 정도 늦어진다고 해도 사용자에게 
**심각한 문제나 불편이 발생할 가능성은 매우 낮습니다.**

이러한 경우 **최종적 일관성** 을 보장하는 방식으로도 충분합니다.
사용자는 쿠폰 증정 지연을 기다릴 필요가 없어 오히려 사용자 경험이 향상되며, 쿠폰도 정상적으로 발급됩니다.

따라서 사용자 경험을 향상하고, **최종적 일관성**만 보장하는 전략을 충분히 선택할 수 있습니다.
