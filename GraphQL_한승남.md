GraphQL 활용
---

### 1. 프로젝트 개요: 🎨 À Moi (아모아)

* **프로젝트명**: À Moi (아모아)
    * 불어로 “나만의, 나의 것”
    * 누구나 쉽게 만들고 감상할 수 있는 모바일 전시회 플랫폼
* **기간**: 2025.04.14 ~ 2025.05.23
* **인원**: 6명
* **역할**: 팀장 & Backend/Infra

### 2. 핵심 기능

* **주제별 고화질 갤러리 + 애니메이션**: 시각적 몰입감을 높이는 전시 기능
* **BGM & 음성 도슨트**: 전시 몰입감 강화
* **스크린샷 방지, 워터마크, 디지털 서명**: 저작권 보호 기능
* **AI 전시 포스터·초대장 자동 생성**: 사용자 편의 기능
* **작가/작품/태그 탐색, 팔로우 & DM**: 네트워킹 기능

---

### 3. 모바일 환경에서 데이터 처리 최적화 (GraphQL 활용)

저희 프로젝트는 **모바일 환경에서 데이터 처리 최적화를 위해 GraphQL과 REST API를 혼합하여 사용**했습니다.

#### 3.1. GraphQL이란?

**GraphQL은 페이스북이 개발한 API를 위한 쿼리 언어이자 런타임 환경입니다.** 클라이언트가 필요한 데이터를 서버에 정확하게 요청하고, 서버는 요청된 데이터만을 응답하는 방식으로 동작합니다. REST API가 리소스 기반으로 동작하는 것과 달리, GraphQL은 **그래프(Graph) 형태의 데이터 모델**을 사용하여 클라이언트가 여러 리소스를 한 번의 요청으로 가져오거나, 필요한 필드만 선택적으로 가져올 수 있게 합니다.

**주요 특징:**

* **선택적 데이터 요청 (Declarative Data Fetching)**: 클라이언트가 필요한 데이터 필드를 직접 지정하여 요청할 수 있습니다. 이는 "오버페칭(Over-fetching)" (필요 이상으로 많은 데이터를 받는 것)과 "언더페칭(Under-fetching)" (필요한 데이터를 모두 받기 위해 여러 번 요청해야 하는 것) 문제를 해결합니다.
* **단일 엔드포인트**: 일반적으로 하나의 HTTP 엔드포인트(`POST /graphql`)를 통해 모든 쿼리와 뮤테이션을 처리합니다.
* **타입 시스템 (Type System)**: 스키마 정의 언어(Schema Definition Language, SDL)를 사용하여 API의 데이터 구조와 사용 가능한 연산을 명확하게 정의합니다. 이를 통해 클라이언트와 서버 간의 계약이 명확해지며, 개발 과정에서 예측 가능성과 안정성을 높입니다.
* **실시간 데이터 처리 (Subscriptions)**: 장기적인 연결을 통해 서버에서 클라이언트로 실시간 데이터를 푸시할 수 있는 기능을 제공합니다.

#### 3.2. REST API와 GraphQL 비교 및 선택 기준

| 구분           | REST API                                    | GraphQL                                     |
| :------------- | :------------------------------------------ | :------------------------------------------ |
| **개념** | 자원(Resource) 중심의 아키텍처              | 쿼리 언어 및 런타임 환경                  |
| **엔드포인트** | 자원마다 다수의 엔드포인트 (e.g., `/users`, `/posts`) | 일반적으로 단일 엔드포인트 (e.g., `/graphql`) |
| **데이터 요청** | 고정된 데이터 구조 응답 (오버/언더페칭 발생 가능) | 필요한 필드만 선택적 요청 (오버/언더페칭 해결) |
| **다중 리소스** | 여러 번의 요청 필요                         | 한 번의 요청으로 여러 리소스 조회 가능    |
| **버전 관리** | API 버전 관리가 흔함 (e.g., `/v1/users`) | 스키마 진화를 통해 유연하게 대응          |
| **사용처** | 단순하고 예측 가능한 자원 조회, 파일 업로드/다운로드 | 복잡한 데이터 관계, 모바일 환경 최적화, 프론트엔드 유연성 필요 시 |

#### 3.3. GraphQL 도입 배경 및 장점

GraphQL은 클라이언트가 필요한 데이터만 선택적으로 요청하고 받을 수 있도록 하는 API 쿼리 언어입니다.

* **데이터 사용량 및 처리 시간 단축**:
    * **예시**: 작품 목록 화면에서는 `작품 ID`와 `작품 썸네일 URL`만을 요청하고, 작품 상세 화면에서는 `설명`, `원본 URL`, `제목` 등 추가적인 데이터를 한 번에 받아올 수 있습니다.
    * 이처럼 화면에서 **필요한 데이터만을 선택적으로 요청**함으로써 모바일 데이터 사용량과 처리 시간을 단축할 수 있어, 모바일 환경에서 특히 강점을 보입니다.
* **프론트엔드 개발 유연성 증대**:
    * 프론트엔드 팀이 필요한 데이터 필드를 직접 조절할 수 있어 백엔드 팀과의 의존성을 줄이고, 전체적인 개발 속도와 유연성을 높일 수 있습니다.
* **효율적인 중첩 데이터 조회 (Nested Data Fetching)**:
    * 사용자가 특정 갤러리를 조회할 때 필요한 모든 연관 데이터를 **단일 네트워크 요청**으로 가져올 수 있어, 여러 번의 API 호출로 인한 지연 시간과 복잡성을 줄일 수 있습니다.
    * **예시**: 갤러리 목록에서는 `작품 ID`와 `썸네일 URL`만 요청하고, 작품 상세 화면에서는 `ID`, `원본 URL`, `제목`, `설명`, `작가 정보`, `댓글 목록` 등 필요한 모든 데이터를 한 번의 요청으로 가져올 수 있습니다.

#### 3.4. REST + GraphQL 혼합 사용 전략

이미 REST 중심으로 구축된 인프라(회원, 인증 등)는 재사용하고, 파일 전송과 같이 REST가 더 적합한 도메인은 REST API를 유지했습니다. GraphQL이 적합한 곳에만 부분적으로 도입하여 러닝커브와 개발 속도 지연을 최소화했습니다.

* **GraphQL 활용 영역**:
    * `목록`, `검색`, `피드`처럼 화면마다 필요한 데이터셋이 수시로 바뀌거나 중첩 관계가 깊은 영역은 GraphQL의 필드 단위 요청으로 페이로드를 최소화했습니다.
* **REST 활용 영역**:
    * `파일 업로드`, `AI 이미지 생성`처럼 대용량·단일 작업 위주의 트랜잭션은 REST가 더 단순하고 안정적이기에 REST를 사용했습니다.
* **코드 재활용**:
    * `회원` 및 `인증`과 같은 핵심 인프라는 이미 REST 중심으로 구축되어 있어, 이를 재활용하여 오버헤드를 최소화했습니다.

---

### 4. GraphQL 응답 형식

GraphQL 요청에 대한 응답은 다음과 같은 형식으로 제공됩니다.

#### 4.1. 성공 시 응답 예시

```json
{
		"data": {
				"getUser": {
						"email": "example@example.com",
						"username": "김자연"
				}
		}
}
```

#### 4.2. 실패 시 응답 예시

```json
{
  "errors": [
    {
      "message": "User not found",
      "extensions": {
        "status": "FAILURE",
        "statusCode": 404,
        "errorCode": "USER-001"
      }
    }
  ],
  "data": {
    "getUserById": null
  }
}
```

---

### 5. GraphQL을 사용한 기능들

`À Moi` 프로젝트에서 GraphQL을 사용하여 구현된 주요 기능들은 다음과 같습니다.

#### 5.1. Query (데이터 조회 일부 예시)

* **회원 관련**:
    * `getUser(userId: ID!)`: 특정 회원 정보 조회
    * `getFollowees(userId: ID!)`: 내가 팔로잉하는 사용자 리스트

* **작품 및 갤러리 관련**:
    * `getArtwork(artworkId: ID!)`: 특정 작품 조회
    * `getGallery(galleryId: ID!)`: 단일 갤러리 조회
    * `getGalleriesOfFollowees(cursor: String, limit: Int = 10)`: 회원이 팔로잉하는 사람들의 갤러리 목록 조회 (커서 기반)
    * `getGalleriesByUser(userId: ID!, cursor: String, limit: Int = 10)`: 회원의 갤러리 목록 조회 (커서 기반)
* **검색 기능**:
    * `searchUsers(keyword: String!, cursor: String, limit: Int = 10)`: 회원 검색
    * `searchGalleries(keyword: String!, cursor: String, limit: Int = 10)`: 갤러리 검색
* **채팅 및 기타**:
    * `getDMRoom(roomId: ID!)`: 채팅방 단일 상세 조회
    * `getDMRooms`: 사용자별 채팅방 목록 조회
 
#### 5.2. Mutation (데이터 변경)

* **회원 관련**:
    * `updateUser(userUpdateInput: UserUpdateInput!)`: 회원 정보 수정
    * `deleteUser`: 회원 탈퇴
* **작품 및 갤러리 좋아요/스크랩**:
    * `likeArtwork(userId: ID!, artworkId: ID!)`: 작품 좋아요
    * `unlikeArtwork(userId: ID!, artworkId: ID!)`: 작품 좋아요 취소

#### 5.3. Type (객체 정의)

* **`User`**: 사용자 정보
* **`Gallery`**: 갤러리 정보
* **`Chapter`**: 갤러리 내 챕터 정보
* **`Artwork`**: 작품 정보
* **연결 타입**: `UserConnection`, `GalleryConnection`, `ArtworkConnection` (커서 기반 페이지네이션을 위한 타입)
* **페이지 정보**: `PageInfo` (`hasNextPage`, `endCursor`, `version`)

---
