
# 01. 개요

## JWT란
- JWT(Json Web Token)은 Json 객체에 인증에 필요한 정보들을 담은 후 비밀키로 서명한 토큰으로, 인터넷 표준 인증 방식이다. 
- 공식적으로 인증(Authentication) & 권한허가(Authorization) 방식으로 사용된다.
## JWT 프로세스

- **로그인 전**
	- 사용자가 아이디와 비밀번호 혹은 소셜 로그인을 활용하여 서버에 **로그인 요청**을 보낸다.
	- 서버는 **비밀키**를 사용해 json 객체를 암호화한 **JWT 토큰을 발급** 한다.
	- JWT를 **헤더**에 담아 클라이언트에 보낸다.
- **로그인 후**
	- 클라이언트는 JWT를 **로컬에 저장**해 놓는다.
	- API 호출을 할 때마다 header에 JWT를 실어 보낸다.
	- 서버는 헤더를 매번 확인하여 사용자가 신뢰할만한지 체크하고, 인증이 되면 APU에 대한 응답을 보낸다.

## HTTP의 특성
<img width="645" height="236" alt="스크린샷 2025-07-15 오전 10 06 58" src="https://github.com/user-attachments/assets/26284bfb-dd34-48a4-a740-cd065c049dc5" />

- HTTP 프로토콜을 사용해서 통신을 할 경우 한 번 통신이 일이나고 나면 연결이 끊어지며 다시 연결해도 이전상태를 유지하지 않아 과거 정보에 대해 기억하지 못한다.
- 화면을 이동해 새로운 API를 요청하면 다시 신뢰할만한 사용자인지 인증하는 과정을 거쳐야 한다.
- 따라서 인증된사용자가 어느 정도 기간동안 재인증 하지 않도록(로그인이 유지되도록) 만든 것이 AccessToken이다.

> **Connectionless**: 한 번 통신이 이뤄지고 난 후에 연결이 바로 끊어짐
> **Stateless**: 이전 상태를 유지/기억하지 않는다.

## JWT의 구조

<img width="750" height="217" alt="스크린샷 2025-07-15 오전 10 07 43" src="https://github.com/user-attachments/assets/719becfe-756a-4410-aaae-1d5998ce4536" />

- **Header**
	- alg: Singaure에서 사용하는 알고리즘 **(헤더를 암호화 하는 것이 아니고, 서명을 해싱하기 위한 알고리즘을 지정하는 것)**
	- typ: 토큰 타입
	- Signautre에서 사용하는 알고리즘은 대표적으로 RS256(공개키/개인키)와 HS256(비밀키(대칭키))가 있다. [참고](https://auth0.com/docs/get-started/applications/signing-algorithms)
- **Payload**
	- **등록된 클레임(Regeistered Claim)** : 토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터
		- sub: 토큰 제목(subject)
		- aud: 토큰 대상자(audience)
		- iat: 토큰이 발급된 시각(issued at)
		- exp: 토큰의 만료 시각(expired)
	- **공개 클레임(Public Claim)**: 사용자 정의 클레임
		- 공개용 정보를 위해 사용
		- 충돌 방지를 위해 URI 포맷을 이용
	- **비공개 클레임(private Claim)** : 사용자 정의 클레임
		- 서버와 클라이언트 사이에 임의로 지정한 정보를 저장
- **Signature**
	- Signature는 헤더와 페이로드의 문자열을 합친 후에 헤더에서 선언한 알고리즘과 key를 이용해 암호화한 값이다.
	- Header와 Payload는 단순히 Base64url로 인코딩 되어 있어 누구나 쉽게 복호화할 수 있다.
	- 하지만 Signaure는 key가 없으면 복호화할 수 없다. 이를 통해 보안상 안전하다는 특성을 가질 수 있게 되었다.
> **성명 생성 과정**
> 1. 헤더와 페이로드의 값을 각각 BASE64로 인코딩
> 2. 인코딩한 값을 비밀 키를 이용해 해더(Header)에서 정의한 알고리즘으로 해싱
> 3. 해싱한 값을 다시 BASE64로 인코딩하여 생성

## JWT 암호화 방법
- Jwt를 생성할 때 헤더와 페이로드 정보를 인코딩 하고, 이들을 합친 문자열에 대해 비밀 키(대칭키, 비대칭키)로 서명을 생성한다.
- **대칭키(Symmetric Key)**
	- 암호화 복호화 키가 같은 방식
	- 같은 키를 사용해 암호화, 복호화를 수행하기 때문에 속도가 빠름
	- 대표적으로 HMAC 암호화 알고리즘이 있음
	- 값에 SHA-256을 적용해서 해싱 후 private key(비밀키, 대칭키 역할)로 암호화
	- private key를 알고있는 서버만 Signaure 유효성 검증이 가능(jwt를 복호화 가능)
- **비대칭키(Asymmetric Key)**
	- 암호화 복호화 키가 다른 방식
	- 다른 키를 사용해 암호화, 복호화를 수행하기 때문에 속도가 느리지만 그만큼 안전
	- 대표적으로 RSA 암호화 알고리즘이 있음
	- 마찬가지로 SHA-256 단방향 암호화 알고리즘과 함께 쓰임
	- 값에 SHA-256를 적용해서 해싱후 priavate key(비밀키)로 암호화
	- public Key(공개키)는 공개적으로 제공, 어떠한 서버든 이 public key를 통해 jwt를 복호화 가능

## JWT의 장단점
- **장점**
	- 서버측 부하를 낮출 수 있고 독립적이기 때문에 능률적으로 접근 권한 관리를 할 수 있고 분산/클라우드 기반 인프라 구조에 잘 대응할 수 있음
	- 별도의 인증 저장소가 필요하지 않아서 인증서버와 db에 의존하지 않아도 됨
- **단점**
	- 서버로부터 받은 토큰이 쿠키 또는 로컬스토리지, 세션스토리지에 저장이 되므로 탈취 당할 위험이 있으므로 token에 중요 정보를 넣지 않아야 함
	- 토큰에 넣는 데이터가 많아질 수록 토큰이 길어지는데 API를 호출할 때마다 토큰 데이터를 서버에 전달해야하므로 그만큼 네트워크 대역폭 낭보기 심할 수 있음


# 02 프로젝트 구현

## 구성

| 클래스명                        | 역할 요약                                                                                                                              |
| --------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| **JwtUtility**              | - JWT 토큰 생성(createAccessToken, createRefreshToken) <br>- 토큰 파싱·검증(validateToken) <br>- 클레임 추출(getUserId, getUserName, getUserType) |
| **TokenService**            | - `JwtUtility`로부터 발급된 토큰(access/refresh)을 받아 <br>- Redis에 리프레시 토큰 저장(saveRefreshToken) <br>- `JwtTokenResponse` DTO 반환             |
| **JwtAuthenticationFilter** | - 모든 요청의 `Authorization` 헤더에서 Bearer 토큰을 꺼내 검증<br>- 유효하면 `Authentication` 생성 후 `SecurityContextHolder`에 등록                         |

## 로그인
<img width="875" height="192" alt="스크린샷 2025-07-15 오전 10 08 25" src="https://github.com/user-attachments/assets/2792bfdc-496e-4234-9db2-03dfc3474be3" />


1. 로그인 요청이 들어오면 로그인 요청을 처리하는 컨트롤러 서비스에서 사용자 검증
2. 검증이 완료된 사용자를 `TokenService` 클래스를 통해 `JwtUtil`클래스에서 토큰 생성
3. 생성된 토큰을 DTO에 담아서 사용자 정보와 함께 사용자에게 반환

## API 호출

<img width="896" height="142" alt="스크린샷 2025-07-15 오전 10 08 52" src="https://github.com/user-attachments/assets/1ec01cee-9e28-491e-91fc-ae0f2a355deb" />

1. 클라이언트가 `Authorization: Bearer 토큰 값` 헤더와 함께 요청
2. `JwtAuthenticationFilter` 클래스의 `doFilterInternal()`에서 헤더 추출
3. `JwtUtil` 클래스에서 유효성 검사
4. 유효성 검사 성공 후 `UserDetails`를 생성 및 `UsernamePasswordAuthenticationToken`생성 후 `SecurityContextHolder`에 저장
5. 그 후 컨트롤러 로직이 실행되며, Spring Security가 인증된 사용자로 인식

# 03 JWT의 목표
## JWT 함정

- **JWT 스테이트리스 상태에 대한 집착**
	- JWT 구현을 위해 스테이트리스 상태가 필요하지만 해당 상태에 집착해야 되는건 아니다.
- **토큰 탈취의 문제**
	- Refresh토큰이 탈취 된다면 AccessToken의 탈취와 같이 동일한 문제가 발생한다.
	- AccessToken보다 요청 주기 자체가 길기 때문에 탈취 당할 확률은 낮지만 탈취 당할 가능성이 있다.
- **서버의 제어권과 로그아웃 문제**
	- 많은 유저들의 토큰이 탈취되면 만료 기간까지 서버에서는 어떤 조치를 취해야 될까?
		- 서버의 비밀키를 변경하는 상활이 생긴다.
	- 프론트에서는 로그아웃을 구현해도 이미 토큰을 복제했다면 계속 서버에 접속할 수 있기 때문에 여전히 문제가 생긴다.
	- 이를 위해 서버측 Redis와 같은 저장소에 발급한 Refresh 토큰을 저장한다는 구현들이 많다.
	- 그래서 로그아웃 상태거나 탈취된 토큰은 Redis서버에서 제거하여 앞으로 Access 토큰 재발급이 불가능 하도록 설정한다.
- **탈취 해결 방법에 대한 모순**
	- Refresh들을 저장하기 위한 Redis를 도입한다면 세션 클러스터링을 작업하고 세션 방식을 사용하는 것은 어떨까?
	- 스테이트리스 작업을 했지만 세션방식과 비슷한 맥락으로 다른 곳에서 상태 저장이 생겨버린다.
- **시도 방법 - IP 검증**
	- 처음 로그인 요청이 된 IP를 JWT에 담아 매번 요청이 올때마다 JWT의 IP와 요청 IP가 동일한지 검증을 진행하는 방법으로 구상
	- 단말기의 IP값이 동적으로 자주 변경되는 상황에서 문제가 될 수 있다.

## JWT를 사용하는 이유

- **모바일 앱**
	- JWT가 사용된 주 이유는 모바일 앱이다. 모바일 앱의 특성상 주로 JWT 방식으로 인증/인가를 진행한다. 즉 스테이트리스는 부수적인 효과다.
- **모바일 앱에서의 로그아웃**
	- 모바일 앱에서는 JWT 탈취 우려가 거의 없다. 앱단에서 로그아웃을 진행하여 JWT 자체를 제거해버리면 서버측에선 추가 조치가 필요하지 않는다. (토큰 자체가 확실하게 없어졌다는 보장이 되기 때문)
- **장시간 로그인 세션**
	- 장시간 동안 로그인 상태를 유지하려고 세션 설정을 하면 서버 측 부하가 많이 가기 때문에 JWT 방식을 하는것도 한 방법
